# 线程生命周期知识点总结

## 🎯 学习目标

完成 Day 2 的学习后，你应该掌握：

1. ✅ 理解线程的 6 种状态
2. ✅ 掌握状态之间的转换条件
3. ✅ 理解状态转换的触发机制
4. ✅ 掌握 getState() 和 isAlive() 方法的使用
5. ✅ 能够在实际开发中正确判断线程状态

---

## 📊 线程的 6 种状态

Java 线程共有 6 种状态，定义在 `Thread.State` 枚举中：

### 1. NEW（新建）

**含义：**
- 线程对象已创建，但尚未调用 `start()` 方法

**特点：**
- 线程还未启动
- 此时 `isAlive()` 返回 `false`

**示例：**
```java
Thread t = new Thread(() -> { ... });
System.out.println(t.getState());  // NEW
System.out.println(t.isAlive());   // false
```

**转换条件：**
- NEW → RUNNABLE：调用 `start()` 方法

---

### 2. RUNNABLE（可运行）

**含义：**
- 调用 `start()` 后的状态
- 包括两种子状态：
  - **Running（运行中）**：正在 CPU 上执行
  - **Ready（就绪）**：等待 CPU 调度

**特点：**
- Java 中不区分 Running 和 Ready 状态
- 都统一表示为 RUNNABLE
- 此时 `isAlive()` 返回 `true`

**示例：**
```java
Thread t = new Thread(() -> { ... });
t.start();
System.out.println(t.getState());  // RUNNABLE
System.out.println(t.isAlive());   // true
```

**转换条件：**
- RUNNABLE → BLOCKED：等待获取监视器锁
- RUNNABLE → WAITING：调用 `wait()`、`join()` 等
- RUNNABLE → TIMED_WAITING：调用 `sleep()`、`wait(timeout)` 等
- RUNNABLE → TERMINATED：`run()` 方法执行完成

---

### 3. BLOCKED（阻塞）

**含义：**
- 等待获取监视器锁（monitor lock）
- 通常是等待进入 `synchronized` 代码块或方法

**触发场景：**
- 线程尝试进入 `synchronized` 代码块
- 但锁被其他线程持有
- 线程会进入 BLOCKED 状态

**示例：**
```java
Object lock = new Object();

Thread t1 = new Thread(() -> {
    synchronized (lock) {
        // 持有锁
        Thread.sleep(5000);
    }
});

Thread t2 = new Thread(() -> {
    synchronized (lock) {  // 等待获取锁
        // 执行代码
    }
});

t1.start();
Thread.sleep(100);  // 确保 t1 先获取锁
t2.start();
Thread.sleep(200);  // 等待 t2 进入 BLOCKED 状态

System.out.println(t2.getState());  // BLOCKED
```

**转换条件：**
- BLOCKED → RUNNABLE：获取到锁
- BLOCKED → TERMINATED：线程被中断或异常

**注意：**
- ⚠️ `synchronized` 是 Java 关键字，不是方法
- ⚠️ BLOCKED 状态只发生在等待 `synchronized` 锁时
- ⚠️ 等待 `Lock` 接口的锁时，状态是 WAITING 或 TIMED_WAITING

**📌 学习提示：**
> **Day 2 学习重点：** 在这个阶段，你只需要知道 `synchronized` 代码块会导致线程进入 BLOCKED 状态即可，不需要深入理解它的原理和详细用法。
> 
> **后续学习安排：**
> - **Day 3-4**：会简单看到 `synchronized` 如何解决线程安全问题
> - **Day 5-7**：会深入讲解 `synchronized` 的原理、用法和最佳实践
> 
> **当前阶段：** 把 `synchronized` 当作一个"魔法工具"，用它来演示 BLOCKED 状态即可。重点关注线程状态本身！

---

### 4. WAITING（等待）

**含义：**
- 无限期等待
- 直到被其他线程唤醒

**触发方法：**
- `Object.wait()` - 等待对象通知
- `Thread.join()` - 等待线程完成
- `LockSupport.park()` - 等待许可

**特点：**
- 没有超时时间
- 需要其他线程主动唤醒
- 此时 `isAlive()` 返回 `true`

**示例：**
```java
Object lock = new Object();

Thread t = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait();  // 进入 WAITING 状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

t.start();
Thread.sleep(200);
System.out.println(t.getState());  // WAITING

// 唤醒线程
synchronized (lock) {
    lock.notify();
}
```

**转换条件：**
- WAITING → RUNNABLE：被唤醒（notify、notifyAll）
- WAITING → TERMINATED：线程被中断或异常

---

### 5. TIMED_WAITING（超时等待）

**含义：**
- 带超时时间的等待
- 到达超时时间后自动唤醒

**触发方法：**
- `Thread.sleep(timeout)` - 休眠指定时间
- `Object.wait(timeout)` - 等待指定时间
- `Thread.join(timeout)` - 等待指定时间
- `LockSupport.parkNanos()` - 等待指定纳秒数

**特点：**
- 有超时时间
- 时间到后自动唤醒
- 此时 `isAlive()` 返回 `true`

**示例：**
```java
Thread t = new Thread(() -> {
    try {
        Thread.sleep(5000);  // 休眠 5 秒
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t.start();
Thread.sleep(200);
System.out.println(t.getState());  // TIMED_WAITING
```

**转换条件：**
- TIMED_WAITING → RUNNABLE：超时时间到或被唤醒
- TIMED_WAITING → TERMINATED：线程被中断或异常

---

### 6. TERMINATED（终止）

**含义：**
- 线程执行完成
- 线程生命周期结束

**触发条件：**
- `run()` 方法正常执行完成
- `run()` 方法抛出未捕获的异常
- 线程被中断

**特点：**
- 线程已死亡
- `isAlive()` 返回 `false`
- 不能再次启动（`start()` 会抛出异常）

**示例：**
```java
Thread t = new Thread(() -> {
    System.out.println("执行完成");
});

t.start();
t.join();  // 等待线程完成

System.out.println(t.getState());  // TERMINATED
System.out.println(t.isAlive());   // false

// t.start();  // ❌ 会抛出 IllegalThreadStateException
```

---

## 🔄 状态转换图

```
NEW
  ↓ (start())
RUNNABLE ←→ BLOCKED (等待 synchronized 锁)
  ↓ (wait/join/park)        ↓ (获取到锁)
WAITING ←→ RUNNABLE
  ↓ (sleep/wait(timeout)/join(timeout))
TIMED_WAITING ←→ RUNNABLE
  ↓ (run() 完成)
TERMINATED
```

---

## 🔍 状态查询方法

### getState()

**作用：** 获取线程的当前状态

**返回：** `Thread.State` 枚举值

**示例：**
```java
Thread t = new Thread(() -> { ... });
System.out.println(t.getState());  // NEW

t.start();
System.out.println(t.getState());  // RUNNABLE
```

**注意：**
- ⚠️ 状态是瞬时的，可能在你查询的下一刻就改变
- ⚠️ 多线程环境下，状态查询和实际状态可能不一致

---

### isAlive()

**作用：** 判断线程是否存活

**返回：** `boolean`
- `true`：线程已启动且尚未终止（RUNNABLE、BLOCKED、WAITING、TIMED_WAITING）
- `false`：线程未启动（NEW）或已终止（TERMINATED）

**示例：**
```java
Thread t = new Thread(() -> { ... });

// NEW 状态
System.out.println(t.isAlive());  // false

t.start();

// RUNNABLE 状态
System.out.println(t.isAlive());  // true

t.join();

// TERMINATED 状态
System.out.println(t.isAlive());  // false
```

**与 getState() 的关系：**
```java
// NEW 或 TERMINATED → isAlive() 返回 false
if (thread.getState() == Thread.State.NEW || 
    thread.getState() == Thread.State.TERMINATED) {
    assert !thread.isAlive();
}

// 其他状态 → isAlive() 返回 true
if (thread.getState() == Thread.State.RUNNABLE ||
    thread.getState() == Thread.State.BLOCKED ||
    thread.getState() == Thread.State.WAITING ||
    thread.getState() == Thread.State.TIMED_WAITING) {
    assert thread.isAlive();
}
```

---

## 📋 状态转换详解

### NEW → RUNNABLE

**触发：** 调用 `start()` 方法

**示例：**
```java
Thread t = new Thread(() -> { ... });
System.out.println(t.getState());  // NEW

t.start();  // 状态转换
System.out.println(t.getState());  // RUNNABLE
```

**注意：**
- ⚠️ 只能调用一次 `start()`，再次调用会抛出 `IllegalThreadStateException`
- ⚠️ 调用 `start()` 后，线程不一定立即运行，取决于 CPU 调度

---

### RUNNABLE → BLOCKED

**触发：** 尝试获取 `synchronized` 锁，但锁被其他线程持有

**示例：**
```java
Object lock = new Object();

Thread t1 = new Thread(() -> {
    synchronized (lock) {
        // 持有锁 5 秒
        Thread.sleep(5000);
    }
});

Thread t2 = new Thread(() -> {
    synchronized (lock) {  // 等待获取锁
        // 执行代码
    }
});

t1.start();
Thread.sleep(100);
t2.start();
Thread.sleep(200);

System.out.println(t2.getState());  // BLOCKED
```

**要点：**
- 只发生在 `synchronized` 锁上
- `Lock` 接口的锁不会产生 BLOCKED 状态

---

### RUNNABLE → WAITING

**触发方法：**
- `Object.wait()` - 必须持有对象锁
- `Thread.join()` - 无参数版本
- `LockSupport.park()` - 无参数版本

**示例：**
```java
Object lock = new Object();
Thread t = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait();  // 进入 WAITING 状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

t.start();
Thread.sleep(200);
System.out.println(t.getState());  // WAITING
```

---

### RUNNABLE → TIMED_WAITING

**触发方法：**
- `Thread.sleep(timeout)`
- `Object.wait(timeout)`
- `Thread.join(timeout)`
- `LockSupport.parkNanos(timeout)`

**示例：**
```java
Thread t = new Thread(() -> {
    try {
        Thread.sleep(5000);  // 休眠 5 秒
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t.start();
Thread.sleep(200);
System.out.println(t.getState());  // TIMED_WAITING
```

---

### 各种状态 → TERMINATED

**触发条件：**
1. `run()` 方法正常执行完成
2. `run()` 方法抛出未捕获的异常
3. 线程被中断且中断处理逻辑导致线程退出

**示例：**
```java
Thread t = new Thread(() -> {
    // 正常执行
    System.out.println("执行完成");
});

t.start();
t.join();

System.out.println(t.getState());  // TERMINATED
```

---

## ⚠️ 注意事项

### 1. 状态是瞬时的

**问题：** 线程状态可能在你查询的下一刻就改变

**解决：**
```java
// ⚠️ 不推荐：状态可能在你查询时就改变了
if (thread.getState() == Thread.State.RUNNABLE) {
    // 此时状态可能已经改变
}

// ✅ 推荐：多次查询或使用其他机制
while (thread.getState() != Thread.State.TERMINATED) {
    Thread.sleep(100);
}
```

---

### 2. 状态转换的时机

**问题：** 调用某个方法后，状态不会立即改变

**示例：**
```java
Thread t = new Thread(() -> {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t.start();
// 此时状态可能还是 RUNNABLE，还没进入 TIMED_WAITING
System.out.println(t.getState());  // 可能是 RUNNABLE

Thread.sleep(100);
// 此时才进入 TIMED_WAITING
System.out.println(t.getState());  // TIMED_WAITING
```

---

### 3. BLOCKED vs WAITING

**区别：**
- **BLOCKED**：等待获取 `synchronized` 锁
- **WAITING**：等待其他线程唤醒（wait、join、park）

**示例对比：**
```java
// BLOCKED：等待 synchronized 锁
Object lock = new Object();
Thread t1 = new Thread(() -> {
    synchronized (lock) { Thread.sleep(5000); }
});
Thread t2 = new Thread(() -> {
    synchronized (lock) { }  // 等待获取锁
});
t1.start();
t2.start();
// t2 的状态：BLOCKED

// WAITING：等待唤醒
Object lock2 = new Object();
Thread t3 = new Thread(() -> {
    synchronized (lock2) {
        try {
            lock2.wait();  // 等待唤醒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
t3.start();
// t3 的状态：WAITING
```

---

### 4. isAlive() 的使用

**注意：**
- `isAlive()` 返回 `true` 不代表线程正在运行
- 可能处于 RUNNABLE、BLOCKED、WAITING、TIMED_WAITING 任一状态

**示例：**
```java
Thread t = new Thread(() -> {
    try {
        Thread.sleep(5000);  // 休眠 5 秒
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

t.start();
Thread.sleep(200);

System.out.println(t.isAlive());   // true（线程存活）
System.out.println(t.getState());  // TIMED_WAITING（但在等待，不在运行）
```

---

## 💡 实际应用场景

### 场景1：监控线程状态

```java
Thread worker = new Thread(() -> {
    // 执行任务
});

worker.start();

// 监控线程状态
while (worker.isAlive()) {
    Thread.State state = worker.getState();
    System.out.println("线程状态: " + state);
    Thread.sleep(100);
}
```

---

### 场景2：等待线程完成

```java
Thread task = new Thread(() -> {
    // 执行任务
});

task.start();

// 等待线程完成
while (task.getState() != Thread.State.TERMINATED) {
    Thread.sleep(100);
}

System.out.println("任务完成");
```

---

### 场景3：判断线程是否正常运行

```java
Thread thread = new Thread(() -> {
    // 执行任务
});

thread.start();

// 检查线程是否正常运行（不是被阻塞）
if (thread.getState() == Thread.State.RUNNABLE) {
    System.out.println("线程正在运行或就绪");
} else if (thread.getState() == Thread.State.BLOCKED) {
    System.out.println("线程被阻塞，等待锁");
} else if (thread.getState() == Thread.State.WAITING ||
           thread.getState() == Thread.State.TIMED_WAITING) {
    System.out.println("线程在等待");
}
```

---

## 📝 总结

### 核心知识点

1. **6 种状态**
   - NEW：新建
   - RUNNABLE：可运行
   - BLOCKED：阻塞（等待 synchronized 锁）
   - WAITING：等待（无限期）
   - TIMED_WAITING：超时等待
   - TERMINATED：终止

2. **状态查询方法**
   - `getState()`：获取线程状态
   - `isAlive()`：判断线程是否存活

3. **状态转换**
   - NEW → RUNNABLE：`start()`
   - RUNNABLE → BLOCKED：等待 `synchronized` 锁
   - RUNNABLE → WAITING：`wait()`、`join()` 等
   - RUNNABLE → TIMED_WAITING：`sleep()`、`wait(timeout)` 等
   - 任意状态 → TERMINATED：`run()` 完成

4. **注意事项**
   - 状态是瞬时的
   - BLOCKED 只发生在 `synchronized` 锁上
   - `isAlive()` 不代表线程正在运行

### 学习检验

完成学习后，你应该能够：
- ✅ 说出线程的 6 种状态
- ✅ 理解每种状态的含义
- ✅ 知道状态转换的触发条件
- ✅ 会使用 `getState()` 和 `isAlive()` 方法
- ✅ 能够判断线程的状态并分析原因

### 记忆口诀

> **新建启动可运行，等待锁时变阻塞，**
> **无限等待叫 WAITING，超时等待 TIMED_WAITING，**
> **执行完成就终止，状态转换要记清。**

