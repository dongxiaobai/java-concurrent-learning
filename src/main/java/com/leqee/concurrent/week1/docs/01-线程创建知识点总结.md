# Week1 线程创建 Demo 知识点总结

## 📚 一、三种创建线程的方式

### 1. 继承 Thread 类

```java
class MyThread extends Thread {
    @Override
    public void run() { ... }
}
```

**特点：**
- 直接继承 Thread 类，重写 `run()` 方法
- 简单直接，适合快速上手

**优点：**
- 代码简单，易于理解

**缺点：**
- Java 单继承限制，扩展性差
- 任务和线程耦合在一起

**使用方式：**
```java
Thread t1 = new MyThread("Thread-1");
t1.start();  // 启动线程
```

---

### 2. 实现 Runnable 接口 ⭐推荐

```java
class MyRunnable implements Runnable {
    @Override
    public void run() { ... }
}
```

**特点：**
- 实现 Runnable 接口，将任务逻辑封装在 `run()` 方法中
- 任务和线程分离，更灵活

**优点：**
- ✅ 解耦：任务和线程分离
- ✅ 可复用：同一个任务可以传给多个线程
- ✅ 灵活：可以继承其他类
- ✅ **推荐方式**：符合面向接口编程思想

**使用方式：**
```java
Thread t = new Thread(new MyRunnable("Task-1"));
t.start();
```

---

### 3. 实现 Callable 接口（有返回值）

```java
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "返回值";
    }
}
```

**特点：**
- 有返回值，可以抛出异常
- 需要配合 `FutureTask` 使用

**优点：**
- ✅ 可以获取任务执行结果
- ✅ 可以抛出异常

**使用方式：**
```java
FutureTask<String> futureTask = new FutureTask<>(new MyCallable("Task"));
Thread t = new Thread(futureTask);
t.start();
String result = futureTask.get();  // 获取返回值（阻塞）
```

---

## 🔄 二、线程的生命周期（6种状态）

Java 线程有 6 种状态，通过 `Thread.getState()` 可以获取：

### 1. NEW（新建）
- **状态**：线程对象已创建，但尚未调用 `start()` 方法
- **特点**：线程还未启动

### 2. RUNNABLE（可运行）
- **状态**：调用 `start()` 后的状态
- **包括**：
  - 正在运行（Running）
  - 就绪等待 CPU 调度（Ready）
- **注意**：Java 中不区分运行中和就绪状态

### 3. BLOCKED（阻塞）
- **状态**：等待获取监视器锁（monitor lock）
- **场景**：进入 `synchronized` 代码块时，锁被其他线程占用

### 4. WAITING（等待）
- **状态**：无限期等待
- **触发方法**：
  - `Object.wait()`
  - `Thread.join()`
  - `LockSupport.park()`

### 5. TIMED_WAITING（超时等待）
- **状态**：带超时的等待
- **触发方法**：
  - `Thread.sleep(timeout)`
  - `Object.wait(timeout)`
  - `Thread.join(timeout)`

### 6. TERMINATED（终止）
- **状态**：线程执行完成或异常退出
- **特点**：线程生命周期结束

**状态转换图：**
```
NEW → RUNNABLE → BLOCKED/WAITING/TIMED_WAITING → TERMINATED
```

---

## 🛠️ 三、线程基本操作

### 1. `start()` vs `run()`

#### `start()` 方法
- ✅ **启动新线程**：JVM 会创建新线程并调用 `run()` 方法
- ✅ **异步执行**：主线程不会等待
- ✅ **只能调用一次**：多次调用会抛出 `IllegalThreadStateException`

#### `run()` 方法
- ❌ **普通方法调用**：不会创建新线程
- ❌ **同步执行**：在当前线程中执行
- ⚠️ **注意**：不要直接调用 `run()`，应该调用 `start()`

**示例：**
```java
Thread t = new Thread(() -> System.out.println("执行"));
t.start();  // ✅ 正确：启动新线程
t.run();    // ❌ 错误：只是普通方法调用
```

---

### 2. `sleep(long millis)` - 线程休眠

**作用：**
- 让当前线程休眠指定时间（毫秒）
- 线程进入 `TIMED_WAITING` 状态

**特点：**
- ✅ **不释放锁**：持有锁的线程休眠时，锁不会被释放
- ✅ **可中断**：休眠期间可以被 `interrupt()` 中断
- ✅ **抛出异常**：被中断时抛出 `InterruptedException`

**示例：**
```java
try {
    Thread.sleep(2000);  // 休眠2秒
} catch (InterruptedException e) {
    // 处理中断异常
}
```

---

### 3. `interrupt()` 和 `isInterrupted()` - 中断线程

#### `interrupt()` 方法
- **作用**：设置线程的中断标志位
- **特点**：
  - 如果线程在 `sleep()`、`wait()`、`join()` 中，会抛出 `InterruptedException`
  - 中断标志会被清除（需要重新设置）

#### `isInterrupted()` 方法
- **作用**：检查线程的中断标志
- **返回**：`true` 表示线程被中断

**中断处理模式：**
```java
Thread t = new Thread(() -> {
    while (!Thread.currentThread().isInterrupted()) {
        // 执行任务
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 捕获中断异常，重新设置中断标志
            Thread.currentThread().interrupt();
            break;  // 退出循环
        }
    }
});
```

---

### 4. `join()` - 等待线程完成

**作用：**
- 等待目标线程执行完成
- 当前线程会阻塞，直到目标线程结束

**方法签名：**
```java
void join()                    // 无限期等待
void join(long millis)         // 等待指定时间
void join(long millis, int nanos)  // 等待指定时间（纳秒精度）
```

**使用场景：**
- 主线程需要等待子线程完成后再继续
- 控制线程执行顺序

**示例：**
```java
Thread t = new Thread(() -> {
    // 执行任务
});
t.start();
t.join();  // 主线程等待 t 完成
System.out.println("t 已完成");
```

---

## 💡 四、重要概念

### 1. 线程信息获取

```java
Thread.currentThread().getName()  // 获取当前线程名称
Thread.currentThread().getId()     // 获取当前线程ID
Thread.currentThread().getState()  // 获取当前线程状态
Thread.currentThread().isAlive()   // 判断线程是否存活
```

### 2. 线程执行顺序

- ⚠️ **不确定**：线程的执行顺序由 JVM 调度决定，不保证顺序
- ✅ **可控**：使用 `join()` 可以控制执行顺序

### 3. 异常处理

- **InterruptedException**：线程被中断时抛出
- **处理方式**：在 `run()` 方法中正确处理异常，不要吞掉异常

---

## ✅ 五、最佳实践

1. **优先使用 Runnable**
   - 避免单继承限制
   - 任务和线程解耦
   - 更灵活，可复用

2. **需要返回值时使用 Callable**
   - 配合 `FutureTask` 使用
   - 可以获取任务执行结果

3. **正确使用 join()**
   - 等待线程完成
   - 控制执行顺序

4. **正确处理 InterruptedException**
   - 不要忽略中断异常
   - 重新设置中断标志或退出

5. **不要直接调用 run()**
   - 应该调用 `start()` 启动线程
   - `run()` 只是普通方法调用

6. **合理使用 sleep()**
   - 注意异常处理
   - 注意不释放锁的特性

---

## 📊 六、三种方式对比总结

| 特性 | Thread | Runnable | Callable |
|------|--------|----------|----------|
| 返回值 | ❌ 无 | ❌ 无 | ✅ 有 |
| 异常 | ❌ 不能抛出 | ❌ 不能抛出 | ✅ 可以抛出 |
| 继承限制 | ❌ 单继承 | ✅ 无限制 | ✅ 无限制 |
| 灵活性 | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 推荐度 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐（需要返回值时） |

---

## 🎯 七、学习要点回顾

### 核心知识点
1. ✅ 三种创建线程的方式及其适用场景
2. ✅ 线程的 6 种生命周期状态
3. ✅ 线程的基本操作方法（start、sleep、interrupt、join）
4. ✅ 线程信息获取方法
5. ✅ 异常处理方式

### 实践建议
- 🔍 **运行代码**：观察线程执行过程
- 🔍 **修改参数**：尝试不同的 sleep 时间、线程数量
- 🔍 **理解状态**：观察线程状态的变化
- 🔍 **对比差异**：理解三种创建方式的区别

---

## 📝 总结

线程创建是 Java 并发编程的基础，掌握这些知识点对于后续学习线程安全、锁机制等内容非常重要。建议：

1. **理解概念**：理解三种创建方式的区别和适用场景
2. **动手实践**：运行代码，观察效果
3. **深入思考**：理解线程的生命周期和状态转换
4. **掌握操作**：熟练使用 sleep、interrupt、join 等方法

这些是 Java 并发编程的基石，后续的线程安全、锁机制等都建立在这些概念之上！

